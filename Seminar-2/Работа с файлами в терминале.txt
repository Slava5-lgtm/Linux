                                                Что такое оболочка?
Начнём с важного вопроса: что же такое на самом деле “оболочка” и зачем она нужна. Оболочка (shell) – это
промежуточное звено между пользователем и операционной системой, основное назначение – интерпретация команд
и передача результатов их выполнения пользователю. Мы вводим команды в оболочке и ОС их выполняет,
возвращая некий результат. Так как мы работаем в текстовом интерфейсе, то команды и их результат также
являются текстом.
В нашей системе Linux чаще всего встречается оболочка bash (Bourne again shell), хотя существуют и другие:
zsh, sh и т.д. Bash это продвинутая версия классической оболочки sh (Bourne shell), которая использовалась
еще в UNIX-системах с 1977 года.
Зная особенности работы с bash, мы сможем эффективно решать задачи в любой Linux-системе. Перейдём к
практике.

                                                Приглашение оболочки (bash)
Первое, что мы видим в терминале после логина – приглашение оболочки bash. Стандартная настройка в Ubuntu
включает в себя следующие элементы:
● логин (имя) пользователя;
● хост (имя компьютера);
● текущий каталог (~ – это домашняя директория);
● указатель типа пользователя (обычный – $ или root – # (супер пользователь(# - имеет не огрониченые
    права))).

            имя пользователя        имя компьютера      текущий каталог     тип пользователя
                    db         @      linux-host:              ~                    $

Все эти элементы важны при работе в системе. Мы понимаем, от имени какого пользователя будет выполнена
команда, на какой системе мы работаем, какой текущий каталог и являемся мы администратором или нет. Формат
приглашения bash можно настроить для себя индивидуально, например, включить дополнительные элементы или
функциональность.

                                                Файловая система

Файлы -> Другие места -> комп (файловая система Линукс - КОРЕНЬ)
Оболчка bash это и есть терминал
Домашняя папка -> показать скрытые файлы -> .bashhrc  -> 
60 строка было так (PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ ')
в терминале (db@db-linux:~$ )
поменял на это
(PS1='\[\033[01;34m\]┏━ \[\033[01;32m\]\u \[\033[00m\]: \[\033[01;34m\]\w\n┗━ \[\033[00m\]')
в терминале (db:~ с новой строкт >)
строка 92 было alias ll='ls -alF' исправили на alias ll='ls -AlFh' - чтобы выводил анойды

.bashrc  ->    строки 95 небыло создали написали alias upd='sudo apt update ; sudo apt upgrade -y'
sudo apt update (обновить список пакетов) sudo apt upgrade -y (чтобы не запрашивал пароль). Команду убрали

                                                Работа с файлами: ls, pwd, cd, mkdir, cp, rm, mv, touch, cat
Давайте определим, где мы находимся в иерархии файлов. Для этого отлично подходит команда pwd, сокращенно
print working directory. Многие команды в Linux составлены из сокращений слов, так их легче запомнить и
быстрее набирать. Кстати, если встречаете короткую команду (две или три буквы), скорее всего это важная и
часто используемая утилита, её стоит запомнить.

                                                ls — список файлов

Вторая полезная команда – ls, сокращенное list. ls позволяет показать список файлов в директории. Формат
вывода может быть разным. Самые популярные параметры это -l, длинный вывод списка и -а – показ всех
элементов, включая скрытые файлы (название которых начинается с точки). Эти параметры можно объединять:
ls -al.

Чтобы перемещаться по дереву каталогов создана команда cd (change directory). У неё есть единственный
параметр: путь. Подробнее о вариантах указания путей поговорим чуть позже.



                                КОМАНДА mkdir

Для создания директорий мы используем команду mkdir (make directory). Если нужно сделать сразу несколько
уровней, добавляем опцию -p.

mkdir - создания деректории
mkdir ~/tmp - создали деректорию tmp
mkdir ~/tmp/dir1 - создали деректорию dir1
mkdir ~/tmp/dir2 - создали деректорию dir2
mkdir ~/tmp/dir2/dir3 - в dir2 создали dir3
mkdir ~/tmp/dir2/dir4 - в dir2 создали dir4
mkdir ~/tmp/dir1/dir5/dir6 - эта команда выдаст ошибку т.к. нет папки dir5
mkdir -p tmp/dir1/dir5/dir6 - а так все отработает

                                КОМАНДА mv
mv - перенос или переменовать
cd tmp - переходим в дерикторию tmp
mkdir dir3 - Создаем деректорию dir3
Переносим из dir1 в dir3
mv dir1/* dir5 - перенос из dir1 переносит все в dir5
mv dir1/dir5 dir3 - перенос из dir1 дерикторию dir5 в dir3 (что перемешяю dir5 и куда dir3)
Если объект сушествует и это папка то идет перемешение. Если объект не папка (dir3) то этот элемент встает на его место
У нас есть папка dir3 хотим его перминовать dir33.
mv dir3 dir33 - перминовали dir3 в dir33

                                КОМАНДА cp

Копированием файлов и директорий занимается команда cp (copy). В большинстве команд, где есть источник и
назначения они указываются именно в таком порядке: откуда-куда. Два основных аргумента команды: источник
(откуда) и назначение (куда). Если мы копируем директорию, нужно указать опцию -r (recursive). Без этой
опции мы не сможем копировать директорию.

cp - копирование
cp dir33/dir5 dir1 - переносим из dir33 dir5 в dir1. У нас ошибка (cp: не указан -r; пропускается каталог 'dir33/dir5') и так не получаеться т.к. нам нужна рекурсия
cp -r dir33/dir5 dir1 - так будит без ошибки

                                rm — удаление

Удалением файлов и директорий заведует команда rm (remove). Для удаления без подтверждения мы можем
использовать опцию -f (force, в Ubuntu она не нужна), рекурсивное удаление (включая вложенные элементы) –
это опция -r, часто они используются вместе: rm -rf. Будьте осторожны при использовании этой команды,
восстановить файлы после удаления будет сложно, никакой “корзины” здесь не будет

rm - удоления
rm 12 - удоляем 12 деректорию. Невозможно удалить '12': Это каталог
rm -r 12 - а так все отработает
rm 12 - папку удолит без проблем с директорию не удолит

                                touch — создание пустого файла
                                        
Команда touch позволяет быстро создать пустой файл. Например, touch test создаст файл test в текущей
директории. У этой команды есть еще множество функций, их можно посмотреть в справке. Напомню, что справку
обычно можно вызвать через ключи -h или --help, а более подробное руководство через команду man touch.

touch - f1
touch - просмтотр файла его последнее действия (мы просто создаем како то файлы)


                                cat — вывод файла, склейка, создание

Команда cat (catenate) также имеет множество применений. Например cat > testfile создаст новый файл и будет
записывать текст из консоли в него. Закончить ввод можно сочетанием Ctrl+D. Если использовать несколько
файлов в качестве источников, можно склеить их содержимое и сохранить в новый файл: cat test test2 > test3.
В этих примерах используется перенаправление ввода-вывода (символ >), которое мы будем подробнее
рассматривать в следующих лекциях. Можно просто распечатать файл в консоль: cat testfile.
Для применения всех перечисленных выше команд нужно корректно указывать пути к файлам и директориям. Что
такое относительные и абсолютные пути, как их использовать мы разберемся далее

cat > f2 - используеться как ввод файла в даном случае f2 (когда закончили наберать текст Ctrl+D)
cat /var/log/apt/history.log - посмотреть содержимое файла
cat /var/log/apt/history.log >f3 - переноправить все содержимое в файл f3
cat fale fale1 fale2 fale3 > fale4 - все файлы склеит и переноправит все содержимое в fale4

                                Ссылки

mkdir links - создаем дерикорию links
cd links/ - переходим в links
touch file - создаем файл
ll - смотрим что там есть
ln file hlink - создаем ссылку (это жеская ссылка на этот файл ln - создать)
ll - смотрим на содержимое
-rw-rw-r-- 2 ubuntu ubuntu 0 дек  4 18:46 file
-rw-rw-r-- 2 ubuntu ubuntu 0 дек  4 18:46 hlink
и видим hlink (жеская ссылка)

nano ../../.bashrc - переходим в nano
Переходим в
# some more ls aliases
alias ll='ls -AlFh - было так 
alias ll='ls -AlFhio' - стало так (чтобы выводил аноды)
. ../../.bashrc
> ln -s file slink - создаем символические ссылку
> ll - смотрим
1470789 -rw-rw-r-- 2 ubuntu 0 дек  4 18:46 file
1470789 -rw-rw-r-- 2 ubuntu 0 дек  4 18:46 hlink
1470791 lrwxrwxrwx 1 ubuntu 4 дек  4 19:07 slink -> file

Анойды (1470789) файла (file) и hlink (жеской сылки) совподают с точки зреня компа это один и тотже файл
с точки зрения место положения в памяти это один и тот же объект.

Символические ссылка это совершено другой объект

> echo "1" > file - написали 1 в file (также это символ > - перезописать)
> cat file - смотрим там это есть
> cat hlink - в жеской ссылки это то же есть
> cat slink - в символические ссылка то же есть
echo '2' >> file - дописать в file (а этот сивол >> - дописать)
Изминения одного из этих элементов (file, hlink, slink), изменяють все
echo "3" >> slink дописали в в любую ссылку все появиться изминения одного элемента идет к изменению всех остольных

mv file new_file - переименовали file в new_file
ll - смотрим что получилось
1470789 -rw-rw-r-- 2 ubuntu 6 дек  4 19:22 hlink
1470789 -rw-rw-r-- 2 ubuntu 6 дек  4 19:22 new_file
1470791 lrwxrwxrwx 1 ubuntu 4 дек  4 19:07 slink -> file (slink -> file - красного цвета)
У него остался тот же самый анойд (1470791)
> cat hlink
1
2
Это ссылка работает она все видит
Но если набрать
> cat slink
cat: slink: Нет такого файла или каталога
То он выводит ошибку т.к. символические ссылка - сылается на имя, а жеская ссыдка - сылаеться на анойд 

Если мы переименуем его обратно mv new_file file
ll - смотрим что получилось
1470789 -rw-rw-r-- 2 ubuntu 6 дек  4 19:22 hlink
1470789 -rw-rw-r-- 2 ubuntu 6 дек  4 19:22 new_file
1470791 lrwxrwxrwx 1 ubuntu 4 дек  4 19:07 slink -> file то мягкая ссылка будет работать


                                        rm — удаление

Удалением файлов и директорий заведует команда rm (remove). Для удаления без подтверждения мы можем
использовать опцию -f (force, в Ubuntu она не нужна), рекурсивное удаление (включая вложенные элементы) –
это опция -r, часто они используются вместе: rm -rf. Будьте осторожны при использовании этой команды,
восстановить файлы после удаления будет сложно, никакой “корзины” здесь не будет.

rm - удоления
rm file - удоляем file
1470789 -rw-rw-r-- 1 ubuntu 6 дек  4 19:22 hlink
1470791 lrwxrwxrwx 1 ubuntu 4 дек  4 19:07 slink -> file
Файл удолии если посмотреть на соержимое жеской сылки
cat hlink
1
2
3
то она живет

echo "999" > file - мы создаем одноименый файл
ll - смотрим что получилось
1470792 -rw-rw-r-- 1 ubuntu 4 дек  4 19:54 file
1470789 -rw-rw-r-- 1 ubuntu 6 дек  4 19:22 hlink
1470791 lrwxrwxrwx 1 ubuntu 4 дек  4 19:07 slink -> file (link - синий)

У него новый айнод 1470792 но старое имя file

cat file
999
cat hlink - выносим содержимое жеской сылки там все еше содержимое таго старого файла
1
2
3
ubuntu : ~/tmp/links
cat slink - а мягкая ссылкауже ссылаеться на новый обект потому что она ссылаеться только на путь.
 ЧТО МЫ ХОТИМ ЧТОБЫ ПРИ УДАЛЕНИИ И ПОЯВЛЕНИИ ФАЙЛА МЫ ЕМЕЛИ ДОСТУП К НЕМУЖЕ (slink -> file)  ИЛИ ПРИ УДАЛЕНИЯ ФАЛА МЫ ИМЕЛИ ДОСТУП К ТАМУ СТАРОМУ ОБРАЗЦУ (hlink).

999

